<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/11/29/bu-ma-chu-fa/"/>
      <url>/2022/11/29/bu-ma-chu-fa/</url>
      
        <content type="html"><![CDATA[<p><img src="C:\Users\HYY\AppData\Roaming\Typora\typora-user-images\image-20221129163412497.png" alt="image-20221129163412497"></p><p>补码除法：符号位参与运算，被除数与除数采用加减交替法，同号相减，异号相加，得到的余数与除数同号则商1，左移一位并减去除数。异号则商0，左移一位并加上除数。</p><p>注意：默认补码余数最后一位为1.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/27/bu-fen-yi-ma-di-zhi-chong-fu/"/>
      <url>/2022/11/27/bu-fen-yi-ma-di-zhi-chong-fu/</url>
      
        <content type="html"><![CDATA[<p>部分译码：只采用高位地址线的一部分进行片选，此时一个存储芯片的某一个地址会对应多个片选信号（例如高位A15    不参与片选，可选0或1，都对其无影响）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/21/fu-dian-shu-zong-jie/"/>
      <url>/2022/11/21/fu-dian-shu-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>浮点数的规格化表示采用IEEE 754标准，此时浮点数阶码为2^n-1 -1,阶码用移码表示，其中全0或全1有特殊用途，所以8位的阶码表示范围为-126~127.</p><p>浮点数基本格式：阶符+阶码数值位+数符+尾数数值位。</p><p>浮点数的运算方式：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/20/2018/"/>
      <url>/2022/11/20/2018/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(linklist A,linklist B,linklist C)</span>{<span class="comment">//带头结点</span></span><br><span class="line">    linklist pa=A-&gt;next;</span><br><span class="line">    linklist pb=B-&gt;next;</span><br><span class="line">    linklist pc=C;</span><br><span class="line">    linklist k;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pa){</span><br><span class="line">        <span class="type">int</span> i=pa-&gt;data;</span><br><span class="line">        pa=pa-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pb){</span><br><span class="line">            <span class="keyword">if</span>(pb-data==i){</span><br><span class="line">                k=(linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));<span class="comment">//这里malloc是为了新建节点k</span></span><br><span class="line">                k-&gt;data=i;</span><br><span class="line">                pc-&gt;next=k;</span><br><span class="line">                pc=pc-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pc-&gt;next=null;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">substr</span><span class="params">(pseqstring s,pseqstring k,<span class="type">int</span> i,<span class="type">int</span> j)</span>{</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p=(<span class="type">char</span>)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(j+<span class="number">1</span>));<span class="comment">//新建j+1个长度的字符数组</span></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=i;t&lt;i+j;t++){<span class="comment">//遍历字符串s第i个之后的j个字符，并将其存入字符数组p</span></span><br><span class="line">        p[q++]=s-&gt;c[t];</span><br><span class="line">    }</span><br><span class="line">    p[q++]=<span class="string">'\0'</span>;<span class="comment">//字符串结尾符号</span></span><br><span class="line">    k-&gt;c=p;<span class="comment">//根据题目给出的字符串结构，建立k这个字符串</span></span><br><span class="line">    k-&gt;n=j;<span class="comment">//当前字符串长度</span></span><br><span class="line">    k-&gt;MAXNUM=S-&gt;MAXNUM;<span class="comment">//最大字符串长度</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/19/2017/"/>
      <url>/2022/11/19/2017/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">算法思想：</span><br><span class="line">    暴力求解：</span><br><span class="line">    求并集，即要求并集中包含A,B中所有元素且不重复，将La直接存入Lc，再找出Lb中与La不重复的元素，存入Lc中，题目要求整体有序，因此最后将Lc进行排序。</span><br><span class="line">    优化：</span><br><span class="line">    因为La，Lb中的元素有序递增，遍历这两个顺序表，如果La的元素小于等于Lb就将La存入Lc，否则就将Lb存入Lc。最后将未遍历完的顺序表所有元素都存入Lc。</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">combine</span><span class="params">(sqlist la,sqlist lb,sqlist lc)</span>{</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;la-&gt;length;i++){</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&gt;=lb-&gt;length){</span><br><span class="line">            lc-&gt;data[k++]=la-&gt;data[i];</span><br><span class="line">            lc-&gt;length++;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lb-&gt;length;j++){</span><br><span class="line">            <span class="keyword">if</span>(la-&gt;data[i]&lt;=lb-&gt;data[j]){</span><br><span class="line">                lc-&gt;data[k++]=la-&gt;data[i];</span><br><span class="line">                lc-&gt;length++;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lc-&gt;data[k++]=lb-&gt;data[j];</span><br><span class="line">                lc-&gt;length++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(j&gt;=la-&gt;length){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=j;s&lt;lb-&gt;length;s++)</span><br><span class="line">           lc-&gt;data[k++]=lb-&gt;data[s];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算法思想：</span><br><span class="line">    遍历这个整形顺序表，一一比较表中元素，如果偶数在前就找到最近的奇数并交换。</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">compare</span><span class="params">(sqlist A)</span>{</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;A-&gt;length<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;A-&gt;length;j++){</span><br><span class="line">            <span class="keyword">if</span>(A-&gt;data[i]%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;A-&gt;data[j]%<span class="number">2</span>!=<span class="number">0</span>){</span><br><span class="line">                temp=A-&gt;data[i];</span><br><span class="line">                A-&gt;data[i]=A-&gt;data[j];</span><br><span class="line">                A-&gt;data[j]=temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/18/2016-suan-fa-ti/"/>
      <url>/2022/11/18/2016-suan-fa-ti/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select</span><span class="params">(sqlist A,sqlist B,sqlist C)</span>{</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;A-&gt;length;i++){</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;B-&gt;lenght;j++){</span><br><span class="line">            <span class="keyword">if</span>(A-&gt;data[i]==B-&gt;data[j])</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>){</span><br><span class="line">            c-&gt;data[k++]=A-&gt;data[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> x)</span>{</span><br><span class="line">    <span class="type">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">if</span>(A[i]==x){</span><br><span class="line">            t=A[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                A[i]=A[i<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            A[<span class="number">0</span>]=t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/04/er-cha-shu-ceng-xu-bian-li/"/>
      <url>/2022/11/04/er-cha-shu-ceng-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<p>二叉树层序遍历</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(Bitree T)</span>{</span><br><span class="line">    initqueen(Q);</span><br><span class="line">    Bitree q;</span><br><span class="line">    enqueen(T);</span><br><span class="line">    <span class="keyword">while</span>(!isempty(Q)){</span><br><span class="line">        dequeen(Q,q);</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild!=null){</span><br><span class="line">            enqueen(Q,q-&gt;lchild);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rchild!=null){</span><br><span class="line">            enqueen(Q,q-&gt;rchild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo Twikoo评论系统美化</title>
      <link href="/2022/10/26/2022-10-26-hexo-twikoo-ping-lun-xi-tong-mei-hua/"/>
      <url>/2022/10/26/2022-10-26-hexo-twikoo-ping-lun-xi-tong-mei-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Twikoo评论系统美化"><a href="#Twikoo评论系统美化" class="headerlink" title="Twikoo评论系统美化"></a>Twikoo评论系统美化</h1><p>在完成博客的twikoo评论系统搭建后，总觉得评论框的白色太过单调，因此决定对评论框进行简单美化。</p><h2 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h2><p>在 blog根目录下的\themes\butterfly\source\css\custom\twikoo_beautify.css中复制粘贴以下代码。（没有就新建）</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Twikoo评论框高度设置 */</span></span><br><span class="line"><span class="selector-class">.el-textarea__inner</span> {</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">180px</span> <span class="meta">!important</span>; //twikoo评论框初始太小，可以自行调节高度</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Twikoo评论框添加背景图*/</span></span><br><span class="line"><span class="selector-class">.el-textarea</span> {</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">/img/comment_bg.png</span>); //自行设定背景图片，支持图片链接</span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">162px</span> <span class="number">75px</span>; //建议自行设置图片大小</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line"><span class="attribute">background-position</span>: right;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">resize</span>: vertical</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Twikoo评论框背景图实现点击下移*/</span></span><br><span class="line"><span class="selector-class">.el-textarea</span><span class="selector-pseudo">:focus</span>-within {</span><br><span class="line"><span class="attribute">background-position</span>-y: <span class="number">800px</span>;</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out <span class="number">0s</span>;</span><br><span class="line">}  //用不到此功能，可以注释掉</span><br></pre></td></tr></tbody></table></figure><p>然后打开主题配置文件，在inject处增加如下代码。</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before '&lt;/head&gt;' tag) and the bottom (before '&lt;/body&gt;' tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel="stylesheet" href="/xxx.css"&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom/twikoo_beautify.css"</span>  <span class="string">media="defer"</span> <span class="string">onload="this.media='all'"&gt;</span>  <span class="comment">#评论美化添加这一句就可以了。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="改变透明度"><a href="#改变透明度" class="headerlink" title="改变透明度"></a>改变透明度</h2><p>参考店长大佬博客：<a href="https://akilar.top/posts/ebf20e02/">Custom Beautify | Akilarの糖果屋</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>弗洛伊德算法</title>
      <link href="/2022/06/14/fu-luo-yi-de-suan-fa/"/>
      <url>/2022/06/14/fu-luo-yi-de-suan-fa/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++){<span class="comment">//确定中转点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){<span class="comment">//遍历整个矩阵，i为行号，j为列号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j]){<span class="comment">//以k为中转点的路径更短 </span></span><br><span class="line">A[i][j]=A[i][k]+A[k][j];<span class="comment">//更新最短路径 </span></span><br><span class="line">path[i][j]=k;<span class="comment">//更新中转点 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2022/06/14/shu-ju-jie-gou-pai-xu-suan-fa-zong-jie/"/>
      <url>/2022/06/14/shu-ju-jie-gou-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-排序算法总结"><a href="#数据结构-排序算法总结" class="headerlink" title="数据结构-排序算法总结"></a>数据结构-排序算法总结</h1><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>插入排序的基本思想是每次将一个待排序的记录按关键字大小插入到前面已排好序的子序列中，直到记录全部插入完成。</p><h3 id="1-1直接插入排序"><a href="#1-1直接插入排序" class="headerlink" title="1.1直接插入排序"></a>1.1直接插入排序</h3><p> 从插入排序的定义我们可以想到一种最为简单的插入排序算法，即确定待排序元素L[i]将要插入的位置k，将待排序序列L[]从k开始一直到L[i-1]的元素全部后移一位，再将L[i]插入k。</p><p>逻辑代码，如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertsort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>{</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++){ <span class="comment">//从A[2]开始依次与前面的元素进行比较</span></span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>]){ <span class="comment">//如果比前面的元素小</span></span><br><span class="line">A[<span class="number">0</span>]=A[i];<span class="comment">//将当前位置i的元素复制到哨兵处</span></span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j){<span class="comment">//再从i-1开始从后向前进行比较，直到遇到比A[0]小的元素就跳出循环</span></span><br><span class="line">A[j+<span class="number">1</span>]=A[j];<span class="comment">//发现比A[0]大的元素就将其向后移动一位</span></span><br><span class="line">}</span><br><span class="line">A[j+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//此时比较完成，将待排序元素插入应插入的位置，此处循环中采用--j，因此排序结束后，指针停留的位置为待插入位置的前一个元素处，因此是j+1</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n)，最坏的情况下为O(n^2)</p><p>稳定性分析：稳定，由于直接插入排序每次都是先比较再移动，因此不会出现相同元素相同位置发生变化的情况。</p><p>适用于顺序和链式存储的线性表</p><h3 id="1-2折半插入排序"><a href="#1-2折半插入排序" class="headerlink" title="1.2折半插入排序"></a>1.2折半插入排序</h3><p>在直接插入排序中每次都是先比较再移动，折半插入排序的基本思想是先折半查找出待插入的位置，再统一的移动之后的所有元素。折半插入排序仅减少了比较元素的次数，复杂度为O(nlog2n)，但移动元素的次数并未改变，因此复杂度仍为O(n^2)</p><h3 id="1-3希尔排序"><a href="#1-3希尔排序" class="headerlink" title="1.3希尔排序"></a>1.3希尔排序</h3><p>根据前面的介绍可以看出，直接插入排序对于基本有序的待排序序列有较低的时间复杂度，因此希尔排序采用：将待排序表分割成若干个小的待排序表，实现方式为将相隔某个增量的记录组成一个子表，然后对各个子表进行直接插入排序，直到所选增量减少为1时，对整个待排序表进行一次直接插入排序。</p><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n^1.3)，最坏的情况下为O(n^2)</p><p>稳定性分析：不稳定，当相同元素分到不同子表时，相对位置可能会发生改变</p><p>只适用于顺序存储的线性表</p><h2 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h2><h3 id="2-1冒泡排序"><a href="#2-1冒泡排序" class="headerlink" title="2.1冒泡排序"></a>2.1冒泡排序</h3><p> 基本思想：从后向前（或者从前向后）两两比较相邻的元素，如果前面的元素大于后面的元素就交换次序，直到所有元素都遍历完，这就是第一趟冒泡排序，可以确定最小元素在序列中的位置。每一趟冒泡排序都会有一个元素确定最终位置，就像🐟吐泡泡一样，最小的元素会逐步冒泡到水面上，至多n-1躺排序就可以确定排序序列。</p><p>冒泡排序会受序列初始状态影响，在代码中设立flag变量，一旦某一趟flag没有改变，就说明已经排好序了。</p><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n)，最坏的情况下为O(n^2)</p><p>稳定性分析：稳定</p><h3 id="2-2快速排序"><a href="#2-2快速排序" class="headerlink" title="2.2快速排序"></a>2.2快速排序</h3><p>基本思想：分治法。首先在待排序序列中任选一个元素作为基准，然后对待排序序列进行比较，保证基准的左侧都是比基准小的元素，右侧都是比基准大的元素。这样一来就确定了基准的最终位置。之后分别递归的对左右序列重复以上步骤，直到每个序列只有一个元素或者为空就停止排序。</p><p>考研中一般选取第一个元素作为基准。</p><p>空间复杂度：由于快速排序是递归调用的，需要一个递归工作站来保存每层调用的递归信息，因此其容量与递归调用深度一致，最好的情况下为O(log2n)，最坏情况下为需要进行n-1躺递归，为O(n)。平均为O(log2n)</p><p>时间复杂度：快速排序算法的时间复杂度与子表的划为是否均衡有关，最坏情况下左子表为n-1，右子表为0，每次需要n-1躺递归，时间复杂度为O(n^2)，最好的情况下左右子表都不超过n/2，时间复杂度为O(nlog2n)，快速排序算法是所有内部排序算法中平均性能最优的算法。</p><p>稳定性分析：不稳定，当选取相同元素作为基准时，元素的相对位置会发生改变。</p><p>*当快速排序的序列基本有序时，不利于发挥快速排序的优势，因为这会导致快速排序划分匹配区间不均匀，每次选取第n个关键字进行划分。</p><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h2><p>基本思想，第i躺选择一个最小元素插入有序序列L[i]中。经过n-1躺排序完成。</p><h3 id="3-1简单选择排序"><a href="#3-1简单选择排序" class="headerlink" title="3.1简单选择排序"></a>3.1简单选择排序</h3><p>基本思想，第i躺从i-n中选择一个最小元素与L[i]<strong>交换</strong>。经过n-1躺排序完成。</p><p>空间复杂度为O(1)</p><p>时间复杂度为O(n^2)，简单选择排序中元素移动的次数较少，一般不超过3(n-1)次，最好的情况是移动0次，即有序。但元素间的比较次数与初始状态无关，始终是n(n-1)/2次。</p><p>稳定性分析：不稳定</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectqort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="type">int</span> i,j,min,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        min=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[i){</span><br><span class="line">                min=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(min!=i){</span><br><span class="line">            t=A[i];</span><br><span class="line">            A[i]=A[min];</span><br><span class="line">            A[min]=t;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2堆排序"><a href="#3-2堆排序" class="headerlink" title="3.2堆排序"></a>3.2堆排序</h3><p>堆：n个关键字序列成为堆。可以将其视为完全二叉树，根节点大于左右孩子的成为大根堆，反之称为小根堆。</p><p>基本思想：首先将待排序序列建成初始堆(大，小)，以大根堆为例，堆顶元素就是最大值，将堆顶元素输出后，把最后一个堆底元素放置到堆顶，此时堆不符合大根堆特性，重新建立大根堆。重复以上步骤，直到堆只剩一个元素为止。</p><p>堆排序的关键是构造初始堆。</p><p>空间复杂度为O(1)</p><p>时间复杂度：建堆时间为O(n)，之后有n-1次向下调整操作，每次O(h)的时间复杂度，时间复杂度为O(nlog2n)。</p><p>稳定性分析：不稳定</p><h2 id="4-归并排序和基数排序"><a href="#4-归并排序和基数排序" class="headerlink" title="4.归并排序和基数排序"></a>4.归并排序和基数排序</h2><h3 id="4-1归并排序"><a href="#4-1归并排序" class="headerlink" title="4.1归并排序"></a>4.1归并排序</h3><p>基本思想：将n个有序序列归并成一个有序序列。一个含有n个关键字的序列可以看成含有n个有序序列，将这些序列两两归并就可以得到n/2个含有2或者1个关键字的有序序列。重复以上步骤，直到合并成一个长度为n的有序序列，归并完成。这种方法成为2路归并。相应的有多路归并。</p><p>空间复杂度为O(n),代码实现中需要将总长度为n的子表复制到另一个一维数组中去，因此需要n的辅助空间。</p><p>时间复杂度：每趟归并需要O(n)的时间复杂度，总共需要进行long2n躺，因此时间复杂度O(nlog2n)。</p><p>稳定性分析：稳定</p><h3 id="4-2基数排序"><a href="#4-2基数排序" class="headerlink" title="4.2基数排序"></a>4.2基数排序</h3><p>基数排序是一种很特别的排序方法，不基于比较和移动，而是基于关键字的大小进行排序。 一般用于日期等特殊类型，对日，月，年等多关键字进行排序，实现对日期这种单逻辑关键字的排序。</p><p>实现多关键字排序一般有两种思想，分别是最高位优先(MSD)和最低位优先(LSD)。简单来讲就是按照关键字的全总递增或递减划为若干子序列，最后再组合成一个有序序列。</p><p>基数排序中，每趟排序都根据相应的关键字进行一趟分配和收集。</p><p>例如对一串具有三位数的序列进行排序，第一趟根据个位的大小分配到相应的队列，然后将得到的各个子序列组合成新的序列。第二趟根据十位的大小进行排序，然后将得到的各个子序列组合成新的序列。第三躺根据百位的大小进行排序，然后将得到的各个子序列组合成最终的序列。</p><p>空间复杂度为O(r),代码实现中需要r个辅助队列，r为关键字能取到的所有值。</p><p>时间复杂度：基数排序需要进行d躺分配和收集，每次分配需要O(n)，每次收集需要O(r)，所以总的时间复杂度为O(d(n+r))。</p><p>稳定性：稳定。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/2022/06/10/guang-du-you-xian-sou-suo-suan-fa/"/>
      <url>/2022/06/10/guang-du-you-xian-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>​      广度优先搜索算法类似二叉树的层序遍历算法，首先访问指定节点v,再从v出发依次访问与v的邻接节点m…..等，直到将图中节点遍历完成。</p><p>​      在无向图中，邻接节点的邻接节点包含已访问过的节点，重复的访问会增加BFS算法的时间复杂度，因此在BFS算法中，实际每次访问的都是未被访问的节点，在代码实现中通常建立一个visit数组，用于存储各节点的访问状态，只寻找访问状态为false的节点。</p><p>​       对于使用邻接表进行存储的图，同一个图，由于邻接表中节点的存储顺序不同，广度优先遍历序列并不唯一。</p><p>​       由于广度优先算法不存在回退这种状态，因此需要建立一个辅助队列以存储当前顶点的下一层节点。</p><p>​       c语言代码实现如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100 <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="comment">//创建一个中断函数 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Interrupt</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//创建一个中断函数 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//用于检测换行符，使函数脱离scanf的连续输出 </span></span><br><span class="line"><span class="keyword">if</span>(getchar()==<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//引入队列，这里是顺序队列 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">int</span> data[MVNum];<span class="comment">//分配给队列一个数组空间 </span></span><br><span class="line"><span class="type">int</span> front;<span class="comment">//队列头 </span></span><br><span class="line"><span class="type">int</span> rear;<span class="comment">//队列尾 </span></span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//初始化队列 </span></span><br><span class="line">{</span><br><span class="line">Q.front = Q.rear = <span class="number">0</span>;<span class="comment">//使队列头和队列尾都为0 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> e)</span><span class="comment">//入队 ，由于是循环队列，故少用一个元素空间，该函数在有MAXSIZE-1个元素时便已判断为满 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MVNum == Q.front)<span class="comment">//判断队列是否为满 ，这里是循环队列队列满的条件是 (Q.rear+1)%MAXSIZE == Q.front</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列已满！\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Q.rear == MVNum)<span class="comment">//如果队尾超出最大值但队列又不满，便使其对最大值求余运算 </span></span><br><span class="line">Q.rear = Q.rear%MVNum;</span><br><span class="line">Q.data[Q.rear] = e;<span class="comment">//使变量e的值入队 </span></span><br><span class="line">Q.rear++;<span class="comment">//并使队尾加一 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span><span class="comment">//队列判空操作 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(Q.front == Q.rear)<span class="comment">//如果队列为空，返回true，否则返回false </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//出队 </span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(QueueEmpty(Q))<span class="comment">//首先判断队列是否为空，队列为空的条件是 Q.front == Q.rear</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列为空！\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">a = Q.data[Q.front];<span class="comment">//导出队头元素数据 </span></span><br><span class="line">Q.front++;<span class="comment">//使队头加一 </span></span><br><span class="line"><span class="keyword">if</span>(!QueueEmpty(Q))<span class="comment">//在队列非空的情况下，如果队头等于最大值，也对最大值做求余运算 </span></span><br><span class="line">Q.front = Q.front%MVNum;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//创建矩阵表操作 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">//该向下一条边的指针 </span></span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//权值 </span></span><br><span class="line">}ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>//顶点信息 </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="type">char</span> data;<span class="comment">//顶点名称 </span></span><br><span class="line">ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针 </span></span><br><span class="line">}VNode,AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//邻接表 </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">AdjList vertices;</span><br><span class="line"><span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点数和边数 </span></span><br><span class="line">}ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGraph</span><span class="params">(ALGraph &amp;G)</span><span class="comment">//图的初始化 </span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MVNum;i++)</span><br><span class="line">G.vertices[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//使所有的第一个结点都置空，也就是后面设定的尾指针的判空操作 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateGraph</span><span class="params">(ALGraph &amp;G)</span><span class="comment">//图的创建 </span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;<span class="comment">//记录次数 </span></span><br><span class="line"><span class="type">char</span> a;<span class="comment">//顶点变量 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入顶点数和边数:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;G.vexnum,&amp;G.arcnum);<span class="comment">//顶点数和边数的赋值 </span></span><br><span class="line">Interrupt();<span class="comment">//该函数用于检测并吸收换行符 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入顶点名称（连续输入）："</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//利用循环输入图中顶点名称 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;a);</span><br><span class="line">G.vertices[i].data = a;<span class="comment">//第i个顶点的命名 </span></span><br><span class="line">}</span><br><span class="line">Interrupt();<span class="comment">//该函数用于检测并吸收换行符</span></span><br><span class="line"><span class="type">char</span> b,c;<span class="comment">//顶点变量 </span></span><br><span class="line"><span class="type">int</span> w,j,k;<span class="comment">//w为权值变量，j和k是用来记录次数的 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcnum;i++)<span class="comment">//利用循环输入所有边的两个顶点和权值 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入边的两个顶点:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c %c"</span>,&amp;b,&amp;c);<span class="comment">//输入 </span></span><br><span class="line">Interrupt();<span class="comment">//该函数用于检测并吸收换行符</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.arcnum;j++)<span class="comment">//该操作为书上的函数LocateVex操作 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(G.vertices[j].data == b)<span class="comment">//找到输入的顶点b的位置 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.arcnum;k++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(G.vertices[k].data == c)<span class="comment">//找到输入的顶点c的位置 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ArcNode *p1,*p2;<span class="comment">//创建两个野结点 </span></span><br><span class="line">p1 = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">p1-&gt;adjvex = k;</span><br><span class="line">p1-&gt;weight = <span class="number">1</span>;<span class="comment">//权值赋值 </span></span><br><span class="line">p1-&gt;nextarc = G.vertices[j].firstarc;<span class="comment">//类似于头插法 </span></span><br><span class="line">G.vertices[j].firstarc = p1;<span class="comment">//并使头结点永远放在第一位 </span></span><br><span class="line">p2 = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">p2-&gt;adjvex = j;</span><br><span class="line">p2-&gt;weight = <span class="number">1</span>;</span><br><span class="line">p2-&gt;nextarc = G.vertices[k].firstarc;</span><br><span class="line">G.vertices[k].firstarc = p2;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputGraph</span><span class="params">(ALGraph G)</span><span class="comment">//邻接表的输出 </span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i,j;<span class="comment">//记录次数 </span></span><br><span class="line">ArcNode *p1;<span class="comment">//用于遍历链表 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"邻接表为：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//利用循环输出 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vertices[i].data);</span><br><span class="line">p1 = G.vertices[i].firstarc;</span><br><span class="line"><span class="keyword">while</span>(p1)<span class="comment">//当p为空时，结束循环 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" --&gt; %d"</span>,p1-&gt;adjvex);</span><br><span class="line">p1 = p1-&gt;nextarc;<span class="comment">//p指向p的下一个结点 </span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//广度优先搜索遍历 </span></span><br><span class="line">ArcNode *p;<span class="comment">//创建一个全局变量，以便于进行查找 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FirstAdjVex</span><span class="params">(ALGraph G,<span class="type">int</span> u)</span><span class="comment">//表示u的第一个邻接点 </span></span><br><span class="line">{</span><br><span class="line">p = G.vertices[u].firstarc;<span class="comment">//全局变量的赋值 </span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//如果头结点的下一个结点为空，返回负数，否则返回p结点的值 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;adjvex;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAdjVex</span><span class="params">(ALGraph G)</span><span class="comment">//下一个邻接点 </span></span><br><span class="line">{</span><br><span class="line">p = p-&gt;nextarc;<span class="comment">//由于p为全局变量，这里直接指向下一个便是 </span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//如果头结点的下一个结点为空，返回负数，否则返回p结点的值  </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;adjvex;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> visited[MVNum];<span class="comment">//访问标志数组 ,其初始值为false </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitVisited</span><span class="params">(<span class="type">bool</span> *visited)</span><span class="comment">//标志数组初始化 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MVNum;i++)</span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">} </span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(ALGraph G,<span class="type">int</span> v)</span><span class="comment">//广度优先搜索遍历 ，非递归形式 </span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vertices[v].data);</span><br><span class="line">visited[v] = <span class="literal">true</span>;<span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true </span></span><br><span class="line">SqQueue Q;</span><br><span class="line">InitQueue(Q);<span class="comment">//引入队列，初始化 </span></span><br><span class="line">EnQueue(Q,v);<span class="comment">//入队 </span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(Q))<span class="comment">//队列非空 </span></span><br><span class="line">{</span><br><span class="line">u = DeQueue(Q);<span class="comment">//出队，别赋值给变量u </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=FirstAdjVex(G,u);w&gt;=<span class="number">0</span>;w=NextAdjVex(G))<span class="comment">//依次检查u的所有邻接点w,w&gt;=0表示存邻接点</span></span><br><span class="line"><span class="comment">//函数FirstAdjVex(G,u)表示u的第一个邻接点，函数NextAdjVex(G)表示相对于w的下一个邻接点 </span></span><br><span class="line"><span class="keyword">if</span>(!visited[w])<span class="comment">//w为u的尚未访问的邻接点 </span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vertices[w].data);</span><br><span class="line">visited[w] = <span class="literal">true</span>;<span class="comment">//访问第w个顶点，并置访问标志数组相应分量值为true </span></span><br><span class="line">EnQueue(Q,w);<span class="comment">//w入队 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">ALGraph G;</span><br><span class="line">InitGraph(G);<span class="comment">//初始化 </span></span><br><span class="line">CreateGraph(G);<span class="comment">//邻接表的创建 </span></span><br><span class="line">InputGraph(G);<span class="comment">//邻接表的输出 </span></span><br><span class="line">BFS(G,<span class="number">2</span>);<span class="comment">//广度优先搜索遍历 ，其中的2为测试值，可更换成变量 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NAT转换</title>
      <link href="/2022/06/08/nat-di-zhi-zhuan-huan/"/>
      <url>/2022/06/08/nat-di-zhi-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>﻿<strong>NAT地址转换</strong><br>现有的网络体系中，我们大多使用ipv4地址进行上网操作，ipv4最大地址为2^32<br>为了便于对IP地址进行管理， 根据IPv4地址的第一个字节，IPv4地址可以分为以下五类。</p><p>A类：0~127</p><p>B类：128~191</p><p>C类：192~223</p><p>D类：224~239，组播地址</p><p>E类：240~254，保留为研究测试使用</p><p>其中私有地址空间为<br><img src="https://img-blog.csdnimg.cn/20210129113120398.png" alt="在这里插入图片描述">私有地址无法直接访问公网</p><p>为了节省紧缺的ipv4地址空间，我们通常采用NAT    地址转换技术<br>NAT分为以下三类：<br><img src="https://img-blog.csdnimg.cn/20210129113301349.png" alt="在这里插入图片描述"><br>以下是NAT转换中涉及的名词<br><img src="https://img-blog.csdnimg.cn/20210129113517270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>NAT会在路由器中生成一张NAT表，在转换时路由器就是通过这张表来转换私有地址的。</p><p>1.静态NAT<br>静态NAT就是在内网用户访问外网时，将内网用户的私有地址转换为公网地址，一个内网用户就要对应一个公网地址，这对于节省ipv4地址意义不大，所以我们经常将静态NAT用在内网中供外网访问的服务器上。<br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129114341199.png" alt="在这里插入图片描述"><br>2.动态NAT<br>动态NAT与静态NAT一样，一个内网用户对应一个公网地址，但不同的是，动态NAT中，我们采用NAT地址池，用户在访问外网时会用地址池动态的获取公网地址。<br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129114616866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt=""><br>值得注意的是在上述配置流程中我们采用了ACL来指定内网中可以访问外网的用户地址段。这就是ACL 的第二个作用。</p><p>3.端口复用<br>端口复用我们也称他为PAT，即端口地址转换<br><img src="https://img-blog.csdnimg.cn/20210129115154225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129115239766.png" alt="在这里插入图片描述"></p><p>在配置PAT时，首先我们要配置允许访问的ACL。然后再将它应用到NAT路由器的outside接口上，接口采用overload过载模式。这样数据包在通过这个接口时，就会在ip地址后加上端口号。一个接口可允许4000个端口号。端口号的知识大家可以自行去查询，我们在浏览器中访问一个网站就是访问它HTTP服务器的80端口。<br>最后查询NAT转换配置的命令是<br>show ip nat translations<br>当然在有数据包通过的时候才能查询到相关内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角形</title>
      <link href="/2022/06/08/acm-dao-li-yang-hui-san-jiao-xing/"/>
      <url>/2022/06/08/acm-dao-li-yang-hui-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<p>﻿Fans喜欢图形，而且喜欢把图形倒过来欣赏。有一次，他看见杨辉三角形 了，觉得很新鲜，于是就把它们大大小小地摆布出来。输入一些整数n（1≤n≤10），读入其每个整数，以该整数为行数，其画出来的倒杨辉三角形（每相邻2个数据由一个空格隔开）就是fans所喜欢欣赏的。Fans是手工做的，你却可以用编程更快捷地做出来，多爽啊!<br>样例输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1 4 6 4 1</span><br><span class="line"> 1 3 3 1</span><br><span class="line">  1 2 1</span><br><span class="line">   1 1</span><br><span class="line">    1</span><br><span class="line">1 2 1</span><br><span class="line"> 1 1</span><br><span class="line">  1</span><br></pre></td></tr></tbody></table></figure><p>解题思路：<br>首先将杨辉三角形存储到二维数组；<br>1<br>11<br>121<br>1331<br>然后倒过来输出，在输出的同时注意题目中要求 每相邻2个数据由一个空格隔开。</p><p>代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">{</span><br><span class="line">int n;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">{</span><br><span class="line">int a[n][n]={};</span><br><span class="line">int i,j,k;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(i==j||j==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">a[i][j]=<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> {</span><br><span class="line"> a[i][j]=a[i-<span class="number">1</span>][j]+a[i-<span class="number">1</span>][j-<span class="number">1</span>];<span class="comment">//杨辉三角形中间的元素是左上角的元素与右上角的元素和</span></span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">cout&lt;&lt;<span class="string">" "</span>;<span class="comment">//输出空格</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n-i;k++)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;a[n-i-<span class="number">1</span>][k];<span class="comment">//从最后一行开始输出，即i=0；</span></span><br><span class="line">cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2022/06/06/shu-ju-jie-gou-kmp-suan-fa-c-yu-yan-shi-xian/"/>
      <url>/2022/06/06/shu-ju-jie-gou-kmp-suan-fa-c-yu-yan-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>﻿最近学习数据结构串的匹配，王道书上只有伪代码实现，于是尝试写出可以运行的c语言代码。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>* T,<span class="type">int</span>* next)</span>{<span class="comment">//求next数组</span></span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(T)){</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||T[j<span class="number">-1</span>]==T[i<span class="number">-1</span>]){</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(T[j<span class="number">-1</span>]!=T[i<span class="number">-1</span>]){</span><br><span class="line">next[i]=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">next[i]=next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">j=next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span>* S,<span class="type">char</span>* T)</span>{<span class="comment">//KMP算法实现</span></span><br><span class="line">  <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">  Next(T,next);</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)){</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>||S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]){</span><br><span class="line">  i++;</span><br><span class="line">  j++;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">  j=next[j];</span><br><span class="line">  }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(j&gt;<span class="built_in">strlen</span>(T)){</span><br><span class="line">  <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line"><span class="type">char</span>* source;</span><br><span class="line">source= (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="type">char</span>* target;</span><br><span class="line">target= (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">gets(source);</span><br><span class="line">gets(target);</span><br><span class="line">    <span class="type">int</span> i=KMP(source,target);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算子串出现次数</title>
      <link href="/2022/06/06/wen-ti-a-string-ji-suan-zi-chuan-chu-xian-ci-shu/"/>
      <url>/2022/06/06/wen-ti-a-string-ji-suan-zi-chuan-chu-xian-ci-shu/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><p>题目描述<br>给定完全由小写字母组成的两个字符串a和b，求b在a中出现的次数</p><p>输入<br>第一行为字符串a；</p><p>第二行为字符串b;</p><p>输出<br>一个整数，表示b在a中出现的次数</p><p>样例输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sharonisagoodgirlihopeshecangetgoodgradesinthefinalexams</span><br><span class="line">in</span><br></pre></td></tr></tbody></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></tbody></table></figure><p>c++中，我常用substr(n,m)函数(从n开始截取长为m的部分字符串)来截取字符串长度，来比对截取部分的代码与子串是否相同。<br>代码：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">{</span><br><span class="line">string a;</span><br><span class="line">string b;</span><br><span class="line">int count=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;a.<span class="title function_">length</span>();i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(a.<span class="title function_">substr</span>(i,b.<span class="title function_">length</span>())==b)</span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
