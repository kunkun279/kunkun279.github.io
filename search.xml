<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>弗洛伊德算法</title>
      <link href="/2022/06/14/fu-luo-yi-de-suan-fa/"/>
      <url>/2022/06/14/fu-luo-yi-de-suan-fa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-lang-c"><code class="language-lang-c">for(int k=0;k<n;k++){//确定中转点     for(int i=0;i<n;i++){//遍历整个矩阵，i为行号，j为列号         for(int j=0;j<n;j++){            if(A[i][j]>A[i][k]+A[k][j]){//以k为中转点的路径更短                 A[i][j]=A[i][k]+A[k][j];//更新最短路径                 path[i][j]=k;//更新中转点             }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2022/06/14/shu-ju-jie-gou-pai-xu-suan-fa-zong-jie/"/>
      <url>/2022/06/14/shu-ju-jie-gou-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-排序算法总结"><a href="#数据结构-排序算法总结" class="headerlink" title="数据结构-排序算法总结"></a>数据结构-排序算法总结</h1><h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>插入排序的基本思想是每次将一个待排序的记录按关键字大小插入到前面已排好序的子序列中，直到记录全部插入完成。</p><h3 id="1-1直接插入排序"><a href="#1-1直接插入排序" class="headerlink" title="1.1直接插入排序"></a>1.1直接插入排序</h3><p> 从插入排序的定义我们可以想到一种最为简单的插入排序算法，即确定待排序元素L[i]将要插入的位置k，将待排序序列L[]从k开始一直到L[i-1]的元素全部后移一位，再将L[i]插入k。</p><p>逻辑代码，如下所示：</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">void insertsort(int A[],int n){    int i,j;    for(int i=2;i<=n;i++){ //从A[2]开始依次与前面的元素进行比较        if(A[i]<A[i-1]){ //如果比前面的元素小            A[0]=A[i];//将当前位置i的元素复制到哨兵处            for(j=i-1;A[0]<A[j];--j){//再从i-1开始从后向前进行比较，直到遇到比A[0]小的元素就跳出循环            A[j+1]=A[j];//发现比A[0]大的元素就将其向后移动一位            }            A[j+1]=A[0];//此时比较完成，将待排序元素插入应插入的位置，此处循环中采用--j，因此排序结束后，指针停留的位置为待插入位置的前一个元素处，因此是j+1        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n)，最坏的情况下为O(n^2)</p><p>稳定性分析：稳定，由于直接插入排序每次都是先比较再移动，因此不会出现相同元素相同位置发生变化的情况。</p><p>适用于顺序和链式存储的线性表</p><h3 id="1-2折半插入排序"><a href="#1-2折半插入排序" class="headerlink" title="1.2折半插入排序"></a>1.2折半插入排序</h3><p>在直接插入排序中每次都是先比较再移动，折半插入排序的基本思想是先折半查找出待插入的位置，再统一的移动之后的所有元素。折半插入排序仅减少了比较元素的次数，复杂度为O(nlog2n)，但移动元素的次数并未改变，因此复杂度仍为O(n^2)</p><h3 id="1-3希尔排序"><a href="#1-3希尔排序" class="headerlink" title="1.3希尔排序"></a>1.3希尔排序</h3><p>根据前面的介绍可以看出，直接插入排序对于基本有序的待排序序列有较低的时间复杂度，因此希尔排序采用：将待排序表分割成若干个小的待排序表，实现方式为将相隔某个增量的记录组成一个子表，然后对各个子表进行直接插入排序，直到所选增量减少为1时，对整个待排序表进行一次直接插入排序。</p><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n^1.3)，最坏的情况下为O(n^2)</p><p>稳定性分析：不稳定，当相同元素分到不同子表时，相对位置可能会发生改变</p><p>只适用于顺序存储的线性表</p><h2 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2.交换排序"></a>2.交换排序</h2><h3 id="2-1冒泡排序"><a href="#2-1冒泡排序" class="headerlink" title="2.1冒泡排序"></a>2.1冒泡排序</h3><p> 基本思想：从后向前（或者从前向后）两两比较相邻的元素，如果前面的元素大于后面的元素就交换次序，直到所有元素都遍历完，这就是第一趟冒泡排序，可以确定最小元素在序列中的位置。每一趟冒泡排序都会有一个元素确定最终位置，就像🐟吐泡泡一样，最小的元素会逐步冒泡到水面上，至多n-1躺排序就可以确定排序序列。</p><p>冒泡排序会受序列初始状态影响，在代码中设立flag变量，一旦某一趟flag没有改变，就说明已经排好序了。</p><p>空间复杂度为O(1)</p><p>时间复杂度最好的情况下为O(n)，最坏的情况下为O(n^2)</p><p>稳定性分析：稳定</p><h3 id="2-2快速排序"><a href="#2-2快速排序" class="headerlink" title="2.2快速排序"></a>2.2快速排序</h3><p>基本思想：分治法。首先在待排序序列中任选一个元素作为基准，然后对待排序序列进行比较，保证基准的左侧都是比基准小的元素，右侧都是比基准大的元素。这样一来就确定了基准的最终位置。之后分别递归的对左右序列重复以上步骤，直到每个序列只有一个元素或者为空就停止排序。</p><p>考研中一般选取第一个元素作为基准。</p><p>空间复杂度：由于快速排序是递归调用的，需要一个递归工作站来保存每层调用的递归信息，因此其容量与递归调用深度一致，最好的情况下为O(log2n)，最坏情况下为需要进行n-1躺递归，为O(n)。平均为O(log2n)</p><p>时间复杂度：快速排序算法的时间复杂度与子表的划为是否均衡有关，最坏情况下左子表为n-1，右子表为0，每次需要n-1躺递归，时间复杂度为O(n^2)，最好的情况下左右子表都不超过n/2，时间复杂度为O(nlog2n)，快速排序算法是所有内部排序算法中平均性能最优的算法。</p><p>稳定性分析：不稳定，当选取相同元素作为基准时，元素的相对位置会发生改变。</p><p>*当快速排序的序列基本有序时，不利于发挥快速排序的优势，因为这会导致快速排序划分匹配区间不均匀，每次选取第n个关键字进行划分。</p><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h2><p>基本思想，第i躺选择一个最小元素插入有序序列L[i]中。经过n-1躺排序完成。</p><h3 id="3-1简单选择排序"><a href="#3-1简单选择排序" class="headerlink" title="3.1简单选择排序"></a>3.1简单选择排序</h3><p>基本思想，第i躺从i-n中选择一个最小元素与L[i]<strong>交换</strong>。经过n-1躺排序完成。</p><p>空间复杂度为O(1)</p><p>时间复杂度为O(n^2)，简单选择排序中元素移动的次数较少，一般不超过3(n-1)次，最好的情况是移动0次，即有序。但元素间的比较次数与初始状态无关，始终是n(n-1)/2次。</p><p>稳定性分析：不稳定</p><h3 id="3-2堆排序"><a href="#3-2堆排序" class="headerlink" title="3.2堆排序"></a>3.2堆排序</h3><p>堆：n个关键字序列成为堆。可以将其视为完全二叉树，根节点大于左右孩子的成为大根堆，反之称为小根堆。</p><p>基本思想：首先将待排序序列建成初始堆(大，小)，以大根堆为例，堆顶元素就是最大值，将堆顶元素输出后，把最后一个堆底元素放置到堆顶，此时堆不符合大根堆特性，重新建立大根堆。重复以上步骤，直到堆只剩一个元素为止。</p><p>堆排序的关键是构造初始堆。</p><p>空间复杂度为O(1)</p><p>时间复杂度：建堆时间为O(n)，之后有n-1次向下调整操作，每次O(h)的时间复杂度，时间复杂度为O(nlog2n)。</p><p>稳定性分析：不稳定</p><h2 id="4-归并排序和基数排序"><a href="#4-归并排序和基数排序" class="headerlink" title="4.归并排序和基数排序"></a>4.归并排序和基数排序</h2><h3 id="4-1归并排序"><a href="#4-1归并排序" class="headerlink" title="4.1归并排序"></a>4.1归并排序</h3><p>基本思想：将n个有序序列归并成一个有序序列。一个含有n个关键字的序列可以看成含有n个有序序列，将这些序列两两归并就可以得到n/2个含有2或者1个关键字的有序序列。重复以上步骤，直到合并成一个长度为n的有序序列，归并完成。这种方法成为2路归并。相应的有多路归并。</p><p>空间复杂度为O(n),代码实现中需要将总长度为n的子表复制到另一个一维数组中去，因此需要n的辅助空间。</p><p>时间复杂度：每趟归并需要O(n)的时间复杂度，总共需要进行long2n躺，因此时间复杂度O(nlog2n)。</p><p>稳定性分析：稳定</p><h3 id="4-2基数排序"><a href="#4-2基数排序" class="headerlink" title="4.2基数排序"></a>4.2基数排序</h3><p>基数排序是一种很特别的排序方法，不基于比较和移动，而是基于关键字的大小进行排序。 一般用于日期等特殊类型，对日，月，年等多关键字进行排序，实现对日期这种单逻辑关键字的排序。</p><p>实现多关键字排序一般有两种思想，分别是最高位优先(MSD)和最低位优先(LSD)。简单来讲就是按照关键字的全总递增或递减划为若干子序列，最后再组合成一个有序序列。</p><p>基数排序中，每趟排序都根据相应的关键字进行一趟分配和收集。</p><p>例如对一串具有三位数的序列进行排序，第一趟根据个位的大小分配到相应的队列，然后将得到的各个子序列组合成新的序列。第二趟根据十位的大小进行排序，然后将得到的各个子序列组合成新的序列。第三躺根据百位的大小进行排序，然后将得到的各个子序列组合成最终的序列。</p><p>空间复杂度为O(r),代码实现中需要r个辅助队列，r为关键字能取到的所有值。</p><p>时间复杂度：基数排序需要进行d躺分配和收集，每次分配需要O(n)，每次收集需要O(r)，所以总的时间复杂度为O(d(n+r))。</p><p>稳定性：稳定。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索t</title>
      <link href="/2022/06/10/guang-du-you-xian-sou-suo-suan-fa/"/>
      <url>/2022/06/10/guang-du-you-xian-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>​      广度优先搜索算法类似二叉树的层序遍历算法，首先访问指定节点v,再从v出发依次访问与v的邻接节点m…..等，直到将图中节点遍历完成。</p><p>​      在无向图中，邻接节点的邻接节点包含已访问过的节点，重复的访问会增加BFS算法的时间复杂度，因此在BFS算法中，实际每次访问的都是未被访问的节点，在代码实现中通常建立一个visit数组，用于存储各节点的访问状态，只寻找访问状态为false的节点。</p><p>​       对于使用邻接表进行存储的图，同一个图，由于邻接表中节点的存储顺序不同，广度优先遍历序列并不唯一。</p><p>​       由于广度优先算法不存在回退这种状态，因此需要建立一个辅助队列以存储当前顶点的下一层节点。</p><p>​       c语言代码实现如下：</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <string.h>#define MVNum 100 //最大顶点数 //创建一个中断函数 void Interrupt(void)//创建一个中断函数 {    while(1)//用于检测换行符，使函数脱离scanf的连续输出         if(getchar()=='\n')            break;} //引入队列，这里是顺序队列 typedef struct{    int data[MVNum];//分配给队列一个数组空间     int front;//队列头     int rear;//队列尾 }SqQueue;void InitQueue(SqQueue &Q)//初始化队列 {    Q.front = Q.rear = 0;//使队列头和队列尾都为0 }void EnQueue(SqQueue &Q,int e)//入队 ，由于是循环队列，故少用一个元素空间，该函数在有MAXSIZE-1个元素时便已判断为满 {    if((Q.rear+1)%MVNum == Q.front)//判断队列是否为满 ，这里是循环队列队列满的条件是 (Q.rear+1)%MAXSIZE == Q.front    {        printf("队列已满！\n");    }    else    {        if(Q.rear == MVNum)//如果队尾超出最大值但队列又不满，便使其对最大值求余运算             Q.rear = Q.rear%MVNum;        Q.data[Q.rear] = e;//使变量e的值入队         Q.rear++;//并使队尾加一     }}bool QueueEmpty(SqQueue Q)//队列判空操作 {    if(Q.front == Q.rear)//如果队列为空，返回true，否则返回false         return true;    else        return false;}int DeQueue(SqQueue &Q)//出队 {    int a = 0;    if(QueueEmpty(Q))//首先判断队列是否为空，队列为空的条件是 Q.front == Q.rear        printf("队列为空！\n");    else    {        a = Q.data[Q.front];//导出队头元素数据         Q.front++;//使队头加一         if(!QueueEmpty(Q))//在队列非空的情况下，如果队头等于最大值，也对最大值做求余运算             Q.front = Q.front%MVNum;    }    return a;}//创建矩阵表操作 typedef struct ArcNode{    int adjvex;//该边所指向的顶点的位置     struct ArcNode *nextarc;//该向下一条边的指针     int weight;//权值 }ArcNode;typedef struct VNode//顶点信息 {    char data;//顶点名称     ArcNode *firstarc;//指向第一条依附该顶点的边的指针 }VNode,AdjList[MVNum];//AdjList表示邻接表类型 typedef struct//邻接表 {    AdjList vertices;    int vexnum,arcnum;//图的当前顶点数和边数 }ALGraph;void InitGraph(ALGraph &G)//图的初始化 {    int i;    for(i=0;i<MVNum;i++)        G.vertices[i].firstarc = NULL;//使所有的第一个结点都置空，也就是后面设定的尾指针的判空操作 }void CreateGraph(ALGraph &G)//图的创建 {    int i;//记录次数     char a;//顶点变量     printf("请输入顶点数和边数:");    scanf("%d %d",&G.vexnum,&G.arcnum);//顶点数和边数的赋值     Interrupt();//该函数用于检测并吸收换行符     printf("请输入顶点名称（连续输入）：");    for(i=0;i<G.vexnum;i++)//利用循环输入图中顶点名称     {        scanf("%c",&a);        G.vertices[i].data = a;//第i个顶点的命名     }    Interrupt();//该函数用于检测并吸收换行符    char b,c;//顶点变量     int w,j,k;//w为权值变量，j和k是用来记录次数的     for(i=0;i<G.arcnum;i++)//利用循环输入所有边的两个顶点和权值     {        printf("请输入边的两个顶点:");        scanf("%c %c",&b,&c);//输入         Interrupt();//该函数用于检测并吸收换行符        for(j=0;j<G.arcnum;j++)//该操作为书上的函数LocateVex操作         {            if(G.vertices[j].data == b)//找到输入的顶点b的位置             break;        }        for(k=0;k<G.arcnum;k++)        {            if(G.vertices[k].data == c)//找到输入的顶点c的位置             break;        }        ArcNode *p1,*p2;//创建两个野结点         p1 = (ArcNode*)malloc(sizeof(ArcNode));        p1->adjvex = k;        p1->weight = 1;//权值赋值         p1->nextarc = G.vertices[j].firstarc;//类似于头插法         G.vertices[j].firstarc = p1;//并使头结点永远放在第一位         p2 = (ArcNode*)malloc(sizeof(ArcNode));        p2->adjvex = j;        p2->weight = 1;        p2->nextarc = G.vertices[k].firstarc;        G.vertices[k].firstarc = p2;    }}void InputGraph(ALGraph G)//邻接表的输出 {    int i,j;//记录次数     ArcNode *p1;//用于遍历链表     printf("邻接表为：\n");    for(i=0;i<G.vexnum;i++)//利用循环输出     {        printf("%c",G.vertices[i].data);        p1 = G.vertices[i].firstarc;        while(p1)//当p为空时，结束循环         {            printf(" --> %d",p1->adjvex);            p1 = p1->nextarc;//p指向p的下一个结点         }            printf("\n");    }}//广度优先搜索遍历 ArcNode *p;//创建一个全局变量，以便于进行查找 int FirstAdjVex(ALGraph G,int u)//表示u的第一个邻接点 {    p = G.vertices[u].firstarc;//全局变量的赋值     if(p == NULL)//如果头结点的下一个结点为空，返回负数，否则返回p结点的值         return -1;    else        return p->adjvex;}int NextAdjVex(ALGraph G)//下一个邻接点 {    p = p->nextarc;//由于p为全局变量，这里直接指向下一个便是     if(p == NULL)//如果头结点的下一个结点为空，返回负数，否则返回p结点的值          return -1;    else        return p->adjvex;}bool visited[MVNum];//访问标志数组 ,其初始值为false void InitVisited(bool *visited)//标志数组初始化 {    for(int i=0;i<MVNum;i++)        visited[i] = false;} void BFS(ALGraph G,int v)//广度优先搜索遍历 ，非递归形式 {    int u;    printf("%c",G.vertices[v].data);    visited[v] = true;//访问第v个顶点，并置访问标志数组相应分量值为true     SqQueue Q;    InitQueue(Q);//引入队列，初始化     EnQueue(Q,v);//入队     while(!QueueEmpty(Q))//队列非空     {        u = DeQueue(Q);//出队，别赋值给变量u         for(int w=FirstAdjVex(G,u);w>=0;w=NextAdjVex(G))//依次检查u的所有邻接点w,w>=0表示存邻接点        //函数FirstAdjVex(G,u)表示u的第一个邻接点，函数NextAdjVex(G)表示相对于w的下一个邻接点             if(!visited[w])//w为u的尚未访问的邻接点             {                printf("%c",G.vertices[w].data);                visited[w] = true;//访问第w个顶点，并置访问标志数组相应分量值为true                 EnQueue(Q,w);//w入队             }    }}int main(){    ALGraph G;    InitGraph(G);//初始化     CreateGraph(G);//邻接表的创建     InputGraph(G);//邻接表的输出     BFS(G,2);//广度优先搜索遍历 ，其中的2为测试值，可更换成变量     return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NAT转换</title>
      <link href="/2022/06/08/nat-di-zhi-zhuan-huan/"/>
      <url>/2022/06/08/nat-di-zhi-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>﻿<strong>NAT地址转换</strong><br>现有的网络体系中，我们大多使用ipv4地址进行上网操作，ipv4最大地址为2^32<br>为了便于对IP地址进行管理， 根据IPv4地址的第一个字节，IPv4地址可以分为以下五类。</p><p>A类：0~127</p><p>B类：128~191</p><p>C类：192~223</p><p>D类：224~239，组播地址</p><p>E类：240~254，保留为研究测试使用</p><p>其中私有地址空间为<br><img src="https://img-blog.csdnimg.cn/20210129113120398.png" alt="在这里插入图片描述">私有地址无法直接访问公网</p><p>为了节省紧缺的ipv4地址空间，我们通常采用NAT    地址转换技术<br>NAT分为以下三类：<br><img src="https://img-blog.csdnimg.cn/20210129113301349.png" alt="在这里插入图片描述"><br>以下是NAT转换中涉及的名词<br><img src="https://img-blog.csdnimg.cn/20210129113517270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>NAT会在路由器中生成一张NAT表，在转换时路由器就是通过这张表来转换私有地址的。</p><p>1.静态NAT<br>静态NAT就是在内网用户访问外网时，将内网用户的私有地址转换为公网地址，一个内网用户就要对应一个公网地址，这对于节省ipv4地址意义不大，所以我们经常将静态NAT用在内网中供外网访问的服务器上。<br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129114341199.png" alt="在这里插入图片描述"><br>2.动态NAT<br>动态NAT与静态NAT一样，一个内网用户对应一个公网地址，但不同的是，动态NAT中，我们采用NAT地址池，用户在访问外网时会用地址池动态的获取公网地址。<br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129114616866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt=""><br>值得注意的是在上述配置流程中我们采用了ACL来指定内网中可以访问外网的用户地址段。这就是ACL 的第二个作用。</p><p>3.端口复用<br>端口复用我们也称他为PAT，即端口地址转换<br><img src="https://img-blog.csdnimg.cn/20210129115154225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk5MDIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>具体配置流程如下：<br><img src="https://img-blog.csdnimg.cn/20210129115239766.png" alt="在这里插入图片描述"></p><p>在配置PAT时，首先我们要配置允许访问的ACL。然后再将它应用到NAT路由器的outside接口上，接口采用overload过载模式。这样数据包在通过这个接口时，就会在ip地址后加上端口号。一个接口可允许4000个端口号。端口号的知识大家可以自行去查询，我们在浏览器中访问一个网站就是访问它HTTP服务器的80端口。<br>最后查询NAT转换配置的命令是<br>show ip nat translations<br>当然在有数据包通过的时候才能查询到相关内容</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角形</title>
      <link href="/2022/06/08/acm-dao-li-yang-hui-san-jiao-xing/"/>
      <url>/2022/06/08/acm-dao-li-yang-hui-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<p>﻿Fans喜欢图形，而且喜欢把图形倒过来欣赏。有一次，他看见杨辉三角形 了，觉得很新鲜，于是就把它们大大小小地摆布出来。输入一些整数n（1≤n≤10），读入其每个整数，以该整数为行数，其画出来的倒杨辉三角形（每相邻2个数据由一个空格隔开）就是fans所喜欢欣赏的。Fans是手工做的，你却可以用编程更快捷地做出来，多爽啊!<br>样例输入</p><pre><code>53</code></pre><p>样例输出</p><pre><code>1 4 6 4 1 1 3 3 1  1 2 1   1 1    11 2 1 1 1  1</code></pre><p>解题思路：<br>首先将杨辉三角形存储到二维数组；<br>1<br>11<br>121<br>1331<br>然后倒过来输出，在输出的同时注意题目中要求 每相邻2个数据由一个空格隔开。</p><p>代码：</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">#include<iostream>using namespace std;int main(){    int n;    while(cin>>n)    {        int a[n][n]={};        int i,j,k;        for( i=0;i<n;i++)        {            for( j=0;j<=i;j++)            {                if(i==j||j==0)                {                    a[i][j]=1;                }                  else                 {                     a[i][j]=a[i-1][j]+a[i-1][j-1];//杨辉三角形中间的元素是左上角的元素与右上角的元素和                 }            }            }        for(i=0;i<n;i++)        {            for(j=0;j<i;j++)                cout<<" ";//输出空格            for(k=0;k<n-i;k++)            {                cout<<a[n-i-1][k];//从最后一行开始输出，即i=0；                cout<<" ";            }            cout<<endl;        }            }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2022/06/06/shu-ju-jie-gou-kmp-suan-fa-c-yu-yan-shi-xian/"/>
      <url>/2022/06/06/shu-ju-jie-gou-kmp-suan-fa-c-yu-yan-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>﻿最近学习数据结构串的匹配，王道书上只有伪代码实现，于是尝试写出可以运行的c语言代码。</p><pre class="line-numbers language-lang-c"><code class="language-lang-c">#include <stdio.h>#include <stdlib.h>#include <string.h>void Next(char* T,int* next){//求next数组    next[1]=0;    next[2]=1;    int j=1;    int i=2;    while(i<strlen(T)){        if(j==0||T[j-1]==T[i-1]){            i++;            j++;            if(T[j-1]!=T[i-1]){                next[i]=j;            }            else{                next[i]=next[j];            }        }        else{            j=next[j];        }    }}int KMP(char* S,char* T){//KMP算法实现      int next[10];      Next(T,next);      int i=1;      int j=1;      while(i<=strlen(S)&&j<=strlen(T)){                if(j==0||S[i-1]==T[j-1]){              i++;              j++;          }          else{              j=next[j];          }      }      if(j>strlen(T)){          return i-(int)strlen(T);      }      return -1;}int main(){    char* source;    source= (char*)malloc(100*sizeof(char));    char* target;    target= (char*)malloc(100*sizeof(char));    gets(source);    gets(target);    int i=KMP(source,target);    printf("%d",i);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算子串出现次数</title>
      <link href="/2022/06/06/wen-ti-a-string-ji-suan-zi-chuan-chu-xian-ci-shu/"/>
      <url>/2022/06/06/wen-ti-a-string-ji-suan-zi-chuan-chu-xian-ci-shu/</url>
      
        <content type="html"><![CDATA[<p>﻿</p><p>题目描述<br>给定完全由小写字母组成的两个字符串a和b，求b在a中出现的次数</p><p>输入<br>第一行为字符串a；</p><p>第二行为字符串b;</p><p>输出<br>一个整数，表示b在a中出现的次数</p><p>样例输入</p><pre><code>sharonisagoodgirlihopeshecangetgoodgradesinthefinalexamsin</code></pre><p>样例输出</p><pre><code>2</code></pre><p>c++中，我常用substr(n,m)函数(从n开始截取长为m的部分字符串)来截取字符串长度，来比对截取部分的代码与子串是否相同。<br>代码：</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">#include<iostream>#include<string>using namespace std;int main(){    string a;    string b;    int count=0;    cin>>a;    cin>>b;    for(int i=0;i<a.length();i++)    {        if(a.substr(i,b.length())==b)        {            count++;        }    }        cout<<count<<endl;        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
